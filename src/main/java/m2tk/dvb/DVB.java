/*
 * Copyright (c) M2TK Project. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package m2tk.dvb;

import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.time.*;

public final class DVB
{
    private DVB()
    {
    }

    public static String translateTerrestrialFrequencyCode(long code)
    {
        return String.format("%,d Hz", code * 10);
    }

    public static String translateSatelliteFrequencyCode(long code)
    {
        int d1 = (int) ((code >> 28) & 0xF);
        int d2 = (int) ((code >> 24) & 0xF);
        int d3 = (int) ((code >> 20) & 0xF);
        int d4 = (int) ((code >> 16) & 0xF);
        int d5 = (int) ((code >> 12) & 0xF);
        int d6 = (int) ((code >> 8) & 0xF);
        int d7 = (int) ((code >> 4) & 0xF);
        int d8 = (int) ((code) & 0xF);
        int p1 = d1 * 100 + d2 * 10 + d3;
        int p2 = d4 * 10000 + d5 * 1000 + d6 * 100 + d7 * 10 + d8;
        return String.format("%03d.%05d GHz", p1, p2);
    }

    public static String translateCableFrequencyCode(long code)
    {
        int d1 = (int) ((code >> 28) & 0xF);
        int d2 = (int) ((code >> 24) & 0xF);
        int d3 = (int) ((code >> 20) & 0xF);
        int d4 = (int) ((code >> 16) & 0xF);
        int d5 = (int) ((code >> 12) & 0xF);
        int d6 = (int) ((code >> 8) & 0xF);
        int d7 = (int) ((code >> 4) & 0xF);
        int d8 = (int) ((code) & 0xF);
        int p1 = d1 * 1000 + d2 * 100 + d3 * 10 + d4;
        int p2 = d5 * 1000 + d6 * 100 + d7 * 10 + d8;
        return String.format("%04d.%04d MHz", p1, p2);
    }

    public static long encodeCableFrequencyCode(String frequency)
    {
        int offset = frequency.indexOf('.');
        long p1 = Integer.parseInt(frequency.substring(0, offset));
        long p2 = Integer.parseInt(frequency.substring(offset + 1));
        long d1 = p1 / 1000;
        long d2 = p1 % 1000 / 100;
        long d3 = p1 % 100 / 10;
        long d4 = p1 % 10;
        long d5 = p2 / 1000;
        long d6 = p2 % 1000 / 100;
        long d7 = p2 % 100 / 10;
        long d8 = p2 % 10;
        return ((d1 << 28) | (d2 << 24) | (d3 << 20) | (d4 << 16) |
                (d5 << 12) | (d6 << 8) | (d7 << 4) | (d8));
    }

    public static String translateSymbolRateCode(int code)
    {
        int d1 = (code >> 24) & 0xF;
        int d2 = (code >> 20) & 0xF;
        int d3 = (code >> 16) & 0xF;
        int d4 = (code >> 12) & 0xF;
        int d5 = (code >> 8) & 0xF;
        int d6 = (code >> 4) & 0xF;
        int d7 = (code) & 0xF;
        int p1 = d1 * 100 + d2 * 10 + d3;
        int p2 = d4 * 1000 + d5 * 100 + d6 * 10 + d7;
        return String.format("%03d.%04d MSymbol/s", p1, p2);
    }

    public static int encodeSymbolRateCode(String rate)
    {
        int offset = rate.indexOf('.');
        int p1 = Integer.parseInt(rate.substring(0, offset));
        int p2 = Integer.parseInt(rate.substring(offset + 1));
        int d1 = p1 / 100;
        int d2 = p1 % 100 / 10;
        int d3 = p1 % 10;
        int d4 = p2 / 1000;
        int d5 = p2 % 1000 / 100;
        int d6 = p2 % 100 / 10;
        int d7 = p2 % 10;
        return (d1 << 24) | (d2 << 20) | (d3 << 16) |
               (d4 << 12) | (d5 << 8) | (d6 << 4) | d7;
    }

    private static int encode_bcd_value(int value)
    {
        return ((value / 10) << 4) | (value % 10);
    }

    private static int decode_bcd_value(int bcd)
    {
        return ((bcd >> 4) & 0xF) * 10 + (bcd & 0xF);
    }

    private static int encode_time_fields(int seconds)
    {
        int hh = seconds / 3600;
        int mm = seconds % 3600 / 60;
        int ss = seconds % 60;
        return (encode_bcd_value(hh) << 16) |
               (encode_bcd_value(mm) << 8) |
               (encode_bcd_value(ss));
    }

    private static int decode_time_fields(int fields)
    {
        int hh = decode_bcd_value((fields >> 16) & 0xFF);
        int mm = decode_bcd_value((fields >> 8) & 0xFF);
        int ss = decode_bcd_value((fields) & 0xFF);
        return hh * 3600 + mm * 60 + ss;
    }

    public static long encodeTimepointFromOffsetDateTime(OffsetDateTime datetime)
    {
        LocalDateTime utcDateTime = datetime.atZoneSameInstant(ZoneId.of("UTC"))
                                            .toLocalDateTime();
        long mjd = encodeDate(utcDateTime.toLocalDate());
        long utc = encodeTime(utcDateTime.toLocalTime());
        return (mjd << 24) | utc;
    }

    public static long encodeTimepointFromLocalDateTime(LocalDateTime datetime)
    {
        LocalDateTime utcDateTime = ZonedDateTime.of(datetime, ZoneId.systemDefault())
                                                 .withZoneSameInstant(ZoneId.of("UTC"))
                                                 .toLocalDateTime();
        long mjd = encodeDate(utcDateTime.toLocalDate());
        long utc = encodeTime(utcDateTime.toLocalTime());
        return (mjd << 24) | utc;
    }

    public static OffsetDateTime decodeTimepointIntoOffsetDateTime(long timepoint)
    {
        // timepoint = [MJD:2]+[UTC:3]
        int mjd = (int) ((timepoint >> 24) & 0x0000FFFFL);
        int utc = (int) ((timepoint) & 0x00FFFFFFL);

        LocalDate date = decodeDate(mjd);
        LocalTime time = decodeTime(utc);
        return ZonedDateTime.of(date, time, ZoneId.of("UTC"))
                            .withZoneSameInstant(ZoneId.systemDefault())
                            .toOffsetDateTime();
    }

    public static LocalDateTime decodeTimepointIntoLocalDateTime(long timepoint)
    {
        // timepoint = [MJD:2]+[UTC:3]
        int mjd = (int) ((timepoint >> 24) & 0x0000FFFFL);
        int utc = (int) ((timepoint) & 0x00FFFFFFL);

        LocalDate date = decodeDate(mjd);
        LocalTime time = decodeTime(utc);
        return ZonedDateTime.of(date, time, ZoneId.of("UTC"))
                            .withZoneSameInstant(ZoneId.systemDefault())
                            .toLocalDateTime();
    }

    public static String printTimeFields(int fields)
    {
        int hh = decode_bcd_value((fields >> 16) & 0xFF);
        int mm = decode_bcd_value((fields >> 8) & 0xFF);
        int ss = decode_bcd_value((fields) & 0xFF);
        return String.format("%02d:%02d:%02d", hh, mm, ss);
    }

    public static int decodeDuration(int duration)
    {
        return decode_time_fields(duration);
    }

    public static int encodeDuration(int seconds)
    {
        return encode_time_fields(seconds);
    }

    public static int encodeTime(LocalTime time)
    {
        int seconds = time.toSecondOfDay();
        return encode_time_fields(seconds);
    }

    public static LocalTime decodeTime(int fields)
    {
        int seconds = decode_time_fields(fields);
        return LocalTime.ofSecondOfDay(seconds);
    }

    public static int encodeDate(LocalDate date)
    {
        return compute24BitMJDFromLocalDate(date);
    }

    public static LocalDate decodeDate(int mjd)
    {
        int mjd24 = adjustMJDFrom16BitTo24Bit(mjd);
        return computeCalendarDateFrom24BitMJD(mjd24);
    }

    private static int adjustMJDFrom16BitTo24Bit(int mjd)
    {
        /* MJD计算公式适用于 1900-03-01 到 2100-02-28 之间的日期，
         * 其值随日期增长而线性增加，范围在[0x3AE7, 0x1583F]。
         *
         * 对于以16位整数存储MJD值，将会出现“上溢归零”现象。即
         * MJD(0xFFFF) + 1 -> MJD(0x0000)，与之对应的日期为 2038-04-22 和 2038-04-23。
         * 也就是说，16位MJD值无法表示 2038-04-22 之后的日期，需要将其扩容（至24位）。
         *
         * 由于MJD是线性增长的，对于公元2000年以后的日期，其MJD值早已超过0x583F，
         * 因此可以将[0x0, 0x583F]内的数值修正为[0x10000, 0x1583F]，从而实现对16位MJD值
         * 的平滑扩容。
         */

        return (mjd > 0x583F) ? mjd : mjd | 0x10000;
    }

    private static LocalDate computeCalendarDateFrom24BitMJD(int mjd)
    {
        /* 从MJD值中还原出年、月、日。
         *
         *    Y' = int [ (MJD - 15078.2) / 365.25 ]
         *    M' = int { [ MJD - 14 956.1 - int (Y' × 365.25) ] / 30.6001 }
         *    D = MJD - 14 956 - int (Y' × 365.25) - int (M' × 30.6001)
         *    If M' = 14 or M' = 15, then K = 1; else K = 0
         *    Y = Y' + K
         *    M = M' - 1 - K × 12
         *
         *  注意：年份从1900开始计算，因此，对于2010年，Y等于110。
         */

        int y = (int) ((mjd - 15078.2) / 365.25);
        int m = (int) ((mjd - 14956.1 - (int) (y * 365.25)) / 30.6001);
        int d = mjd - 14956 - (int) (y * 365.25) - (int) (m * 30.6001);
        int k = (m == 14 || m == 15) ? 1 : 0;

        int year = 1900 + y + k;
        int month = m - 1 - k * 12;
        int day = d;
        return LocalDate.of(year, month, day);
    }

    private static int compute24BitMJDFromLocalDate(LocalDate date)
    {
        /* 根据年、月、日计算MJD值。
         *
         *    MJD = 14956 + D + int [(Y - K) × 365.25] + int [(M + 1 + K × 12) × 30.6001]
         *    If M = 1 or M = 2, then K = 1; else K = 0
         *
         *  注意：年份从1900开始计算，因此，对于2010年，Y等于110。
         */

        int y = date.getYear() - 1900;
        int m = date.getMonthValue();
        int d = date.getDayOfMonth();
        int k = (m == 1 || m == 2) ? 1 : 0;

        return 14956 + d + (int) ((y - k) * 365.25) + (int) ((m + 1 + k * 12) * 30.6001);
    }

    public static String decodeThreeLetterCode(int code)
    {
        byte[] bytes = new byte[3];
        bytes[0] = (byte) ((code >> 16) & 0xFF);
        bytes[1] = (byte) ((code >> 8) & 0xFF);
        bytes[2] = (byte) ((code) & 0xFF);
        return new String(bytes);
    }

    /* 符合国标（GB/T 28161-2011）要求的字符串编解码器。
     * 注意：国标对 DVB 规范（ETSI EN-300.468）进行了适当的裁剪，省略了部分拉丁字符集。
     *      鉴于国内不规范的编解码方式，“默认字符集”设为 GBK 而非规范中定义的拉丁字符。
     */
    public static String decodeString(byte[] bytes)
    {
        return decodeString(bytes, 0, bytes.length);
    }

    public static String decodeString(byte[] bytes, int offset, int length)
    {
        if (length == 0)
            return "";

        int first_byte = bytes[offset] & 0xFF;
        if (first_byte >= 0x20)
            return construct_string_safely(bytes, offset, length, "GBK");

        if (first_byte == 0x01)
            return construct_string_using_table(bytes, offset + 1, length - 1, TABLE_01_AKA_8859_5);

        if (first_byte == 0x02)
            return construct_string_using_table(bytes, offset + 1, length - 1, TABLE_02_AKA_8859_6);

        if (first_byte == 0x03)
            return construct_string_using_table(bytes, offset + 1, length - 1, TABLE_03_AKA_8859_7);

        if (first_byte == 0x04)
            return construct_string_using_table(bytes, offset + 1, length - 1, TABLE_04_AKA_8859_8);

        if (first_byte == 0x05)
            return construct_string_using_table(bytes, offset + 1, length - 1, TABLE_05_AKA_8859_9);

        if (first_byte == 0x06)
            return construct_string_using_table(bytes, offset + 1, length - 1, TABLE_06_AKA_8859_10);

        if (first_byte == 0x07)
            return construct_string_using_table(bytes, offset + 1, length - 1, TABLE_07_AKA_8859_11);

        if (first_byte == 0x09)
            return construct_string_using_table(bytes, offset + 1, length - 1, TABLE_09_AKA_8859_13);

        if (first_byte == 0x0A)
            return construct_string_using_table(bytes, offset + 1, length - 1, TABLE_0A_AKA_8859_14);

        if (first_byte == 0x0B)
            return construct_string_using_table(bytes, offset + 1, length - 1, TABLE_0B_AKA_8859_15);

        if (first_byte == 0x10)
        {
            int second_byte = bytes[offset + 1] & 0xFF;
            int third_byte = bytes[offset + 2] & 0xFF;

            if (second_byte != 0x00 || third_byte >= 0x10)
                return construct_string_safely(bytes, offset + 3, length - 3, "UTF-8");

            switch (third_byte)
            {
                case 0x01:
                    return construct_string_safely(bytes, offset + 3, length - 3, "ISO-8859-1");
                case 0x02:
                    return construct_string_safely(bytes, offset + 3, length - 3, "ISO-8859-2");
                case 0x03:
                    return construct_string_safely(bytes, offset + 3, length - 3, "ISO-8859-3");
                case 0x04:
                    return construct_string_safely(bytes, offset + 3, length - 3, "ISO-8859-4");
                case 0x05:
                    return construct_string_using_table(bytes, offset + 3, length - 3, TABLE_01_AKA_8859_5);
                case 0x06:
                    return construct_string_using_table(bytes, offset + 3, length - 3, TABLE_02_AKA_8859_6);
                case 0x07:
                    return construct_string_using_table(bytes, offset + 3, length - 3, TABLE_03_AKA_8859_7);
                case 0x08:
                    return construct_string_using_table(bytes, offset + 3, length - 3, TABLE_04_AKA_8859_8);
                case 0x09:
                    return construct_string_using_table(bytes, offset + 3, length - 3, TABLE_05_AKA_8859_9);
                case 0x0A:
                    return construct_string_using_table(bytes, offset + 3, length - 3, TABLE_06_AKA_8859_10);
                case 0x0B:
                    return construct_string_using_table(bytes, offset + 3, length - 3, TABLE_07_AKA_8859_11);
                case 0x0D:
                    return construct_string_using_table(bytes, offset + 3, length - 3, TABLE_09_AKA_8859_13);
                case 0x0E:
                    return construct_string_using_table(bytes, offset + 3, length - 3, TABLE_0A_AKA_8859_14);
                case 0x0F:
                    return construct_string_using_table(bytes, offset + 3, length - 3, TABLE_0B_AKA_8859_15);
                default:
                    return construct_string_safely(bytes, offset + 3, length - 3, "UTF-8");
            }
        }

        if (first_byte == 0x11)
            return construct_string_safely(bytes, offset + 1, length - 1, "GBK");

        if (first_byte == 0x13)
            return construct_string_safely(bytes, offset + 1, length - 1, "GB2312");

        if (first_byte == 0x15)
            return construct_string_safely(bytes, offset + 1, length - 1, "UTF-8");

        // 日文编码按照ARIB STD-B24相关规定进行解码，这里暂不支持。
        // 对其他情况，去掉控制字节，剩余字节使用系统默认字符集解码。
        return new String(bytes, offset + 1, length - 1);
    }

    public static int encodeString(String string, byte[] bytes, int offset)
    {
        if (string == null || string.isEmpty())
            return 0;

        byte[] encoding;
        try
        {
            encoding = string.getBytes("GBK");
        } catch (Exception ex)
        {
            encoding = string.getBytes();
        }

        System.arraycopy(encoding, 0, bytes, offset, encoding.length);
        return encoding.length;
    }

    public static int encodeWithGBKCharset(String string, byte[] bytes, int offset)
    {
        if (string == null || string.isEmpty())
            return 0;

        try
        {
            bytes[offset] = 0x13;
            byte[] encoding = string.getBytes("GBK");
            System.arraycopy(encoding, 0, bytes, offset + 1, encoding.length);
            return encoding.length + 1;
        } catch (Exception ignored)
        {
            // 理论上在中文环境下不会抛出此异常。
            bytes[offset] = 0x13;
            byte[] encoding = string.getBytes(StandardCharsets.ISO_8859_1);
            System.arraycopy(encoding, 0, bytes, offset + 1, encoding.length);
            return encoding.length + 1;
        }
    }

    public static int encodeInASCII(String string, byte[] bytes, int offset)
    {
        if (string == null || string.isEmpty())
            return 0;

        byte[] encoding = string.getBytes(StandardCharsets.US_ASCII);
        if (encoding.length + offset > bytes.length)
            throw new IllegalArgumentException("string too long");

        System.arraycopy(encoding, 0, bytes, offset, encoding.length);
        return encoding.length;
    }

    public static int encodeInGBK(String string, byte[] bytes, int offset)
    {
        if (string == null || string.isEmpty())
            return 0;

        try
        {
            bytes[offset] = 0x11; // GBK 等同于 ISO 10646
            byte[] encoding = string.getBytes("GBK");
            if (encoding.length + 1 + offset > bytes.length)
                throw new IllegalArgumentException("string too long");

            System.arraycopy(encoding, 0, bytes, offset + 1, encoding.length);
            return encoding.length + 1;
        } catch (UnsupportedEncodingException ex)
        {
            // 理论上在中文环境下不会抛出此异常。
            return encodeInUTF8(string, bytes, offset);
        }
    }

    public static int encodeInGB2312(String string, byte[] bytes, int offset)
    {
        if (string == null || string.isEmpty())
            return 0;

        try
        {
            bytes[offset] = 0x13;
            byte[] encoding = string.getBytes("GB2312");
            if (encoding.length + 1 + offset > bytes.length)
                throw new IllegalArgumentException("string too long");

            System.arraycopy(encoding, 0, bytes, offset + 1, encoding.length);
            return encoding.length + 1;
        } catch (UnsupportedEncodingException ex)
        {
            // 理论上在中文环境下不会抛出此异常。
            return encodeInUTF8(string, bytes, offset);
        }
    }

    public static int encodeInBig5(String string, byte[] bytes, int offset)
    {
        if (string == null || string.isEmpty())
            return 0;

        try
        {
            bytes[offset] = 0x14;
            byte[] encoding = string.getBytes("Big5");
            if (encoding.length + 1 + offset > bytes.length)
                throw new IllegalArgumentException("string too long");

            System.arraycopy(encoding, 0, bytes, offset + 1, encoding.length);
            return encoding.length + 1;
        } catch (UnsupportedEncodingException ex)
        {
            // 理论上在中文环境下不会抛出此异常。
            return encodeInUTF8(string, bytes, offset);
        }
    }

    public static int encodeInUTF8(String string, byte[] bytes, int offset)
    {
        if (string == null || string.isEmpty())
            return 0;

        bytes[offset] = 0x15;
        byte[] encoding = string.getBytes(StandardCharsets.UTF_8);
        if (encoding.length + 1 + offset > bytes.length)
            throw new IllegalArgumentException("string too long");

        System.arraycopy(encoding, 0, bytes, offset + 1, encoding.length);
        return encoding.length + 1;
    }

    private static String construct_string_safely(byte[] bytes, int offset, int length, String charset)
    {
        try
        {
            return new String(bytes, offset, length, Charset.forName(charset));
        } catch (Exception ex)
        {
            return new String(bytes, offset, length, Charset.forName("GBK"));
        }
    }

    private static String construct_string_using_table(byte[] bytes, int offset, int length, char[] table)
    {
        char[] chars = new char[length];
        for (int i = 0; i < length; i++)
        {
            int b = bytes[i + offset] & 0xFF;
            chars[i] = table[b];
        }
        return new String(chars);
    }

    private static final char[] TABLE_00 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x20AC, 0x00A5, 0x0000, 0x00A7, 0x00A4, 0x2018, 0x201C, 0x00AB, 0x2190, 0x2191, 0x2192, 0x2193, // A-
        0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00D7, 0x00B5, 0x00B6, 0x00B7, 0x00F7, 0x2019, 0x201D, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF, // B-
        0x0000, 0x0300, 0x0301, 0x0302, 0x0303, 0x0304, 0x0306, 0x0307, 0x0308, 0x0000, 0x030A, 0x0327, 0x0000, 0x030B, 0x0328, 0x030C, // C-
        0x2015, 0x00B9, 0x00AE, 0x00A9, 0x2122, 0x266A, 0x00AC, 0x00A6, 0x0000, 0x0000, 0x0000, 0x0000, 0x215B, 0x215C, 0x215D, 0x215E, // D-
        0x2126, 0x00C6, 0x0110, 0x00AA, 0x0126, 0x0000, 0x0132, 0x013F, 0x0141, 0x00D8, 0x0152, 0x00BA, 0x00DE, 0x0166, 0x014A, 0x0149, // E-
        0x0138, 0x00E6, 0x0111, 0x00F0, 0x0127, 0x0131, 0x0133, 0x0140, 0x0142, 0x00F8, 0x0153, 0x00DF, 0x00FE, 0x0167, 0x014B, 0x00AD  // F-
    };

    // Compatible with ISO/IEC 8859-5
    private static final char[] TABLE_01_AKA_8859_5 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0406, 0x0407, 0x0408, 0x0409, 0x040A, 0x040B, 0x040C, 0x00AD, 0x040E, 0x040F, // A-
        0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F, // B-
        0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F, // C-
        0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F, // D-
        0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F, // E-
        0x2116, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0415, 0x0458, 0x0459, 0x045A, 0x045B, 0x045C, 0x00A7, 0x045E, 0x045F  // F-
    };

    // Compatible with ISO/IEC 8859-6
    private static final char[] TABLE_02_AKA_8859_6 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x0000, 0x0000, 0x0000, 0x00A4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x060C, 0x00AD, 0x0000, 0x0000, // A-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x061B, 0x0000, 0x0000, 0x0000, 0x061F, // B-
        0x0000, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627, 0x0628, 0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F, // C-
        0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637, 0x0638, 0x0639, 0x063A, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // D-
        0x0640, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649, 0x064A, 0x064B, 0x064C, 0x064D, 0x064E, 0x064F, // E-
        0x0650, 0x0651, 0x0652, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000  // F-
    };

    // Compatible with ISO/IEC 8859-7
    private static final char[] TABLE_03_AKA_8859_7 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x2018, 0x2019, 0x00A3, 0x20AC, 0x20AF, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x037A, 0x00AB, 0x00AC, 0x00AD, 0x0000, 0x2015, // A-
        0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x0384, 0x0385, 0x0386, 0x0387, 0x0388, 0x0389, 0x038A, 0x00BB, 0x038C, 0x00BD, 0x038E, 0x038F, // B-
        0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x0398, 0x0399, 0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F, // C-
        0x03A0, 0x03A1, 0x0000, 0x03A3, 0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9, 0x03AA, 0x03AB, 0x03AC, 0x03AD, 0x03AE, 0x03AF, // D-
        0x03B0, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7, 0x03B8, 0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF, // E-
        0x03C0, 0x03C1, 0x03C2, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7, 0x03C8, 0x03C9, 0x03CA, 0x03CB, 0x03CC, 0x03CD, 0x03CE, 0x0000  // F-
    };

    // Compatible with ISO/IEC 8859-8
    private static final char[] TABLE_04_AKA_8859_8 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x0000, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00D7, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF, // A-
        0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x00B9, 0x00F7, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x0000, // B-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // C-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2017, // D-
        0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF, // E-
        0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7, 0x05E8, 0x05E9, 0x05EA, 0x0000, 0x0000, 0x200E, 0x200F, 0x0000  // F-
    };

    // Compatible with ISO/IEC 8859-9
    private static final char[] TABLE_05_AKA_8859_9 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00D7, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF, // A-
        0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x00B9, 0x00F7, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF, // B-
        0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, 0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, // C-
        0x011E, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x0130, 0x015E, 0x00DF, // D-
        0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF, // E-
        0x011F, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, 0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x0131, 0x015F, 0x00FF  // F-
    };


    // Compatible with ISO/IEC 8859-10
    private static final char[] TABLE_06_AKA_8859_10 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x0104, 0x0112, 0x0122, 0x012A, 0x0128, 0x0136, 0x00A7, 0x013B, 0x0110, 0x0160, 0x0166, 0x017D, 0x00AD, 0x016A, 0x014A, // A-
        0x00B0, 0x0105, 0x0113, 0x0123, 0x012B, 0x0129, 0x0137, 0x00B7, 0x013C, 0x0111, 0x0161, 0x0167, 0x017E, 0x2015, 0x016B, 0x014B, // B-
        0x0100, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x012E, 0x010C, 0x00C9, 0x0118, 0x00CB, 0x0116, 0x00CD, 0x00CE, 0x00CF, // C-
        0x00D0, 0x0145, 0x014C, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x0168, 0x00D8, 0x0172, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF, // D-
        0x0101, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x012F, 0x010D, 0x00E9, 0x0119, 0x00EB, 0x0117, 0x00ED, 0x00EE, 0x00EF, // E-
        0x00F0, 0x0146, 0x014D, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x0169, 0x00F8, 0x0173, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x0138  // F-
    };


    // Compatible with ISO/IEC 8859-11
    private static final char[] TABLE_07_AKA_8859_11 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x0E01, 0x0E02, 0x0E03, 0x0E04, 0x0E05, 0x0E06, 0x0E07, 0x0E08, 0x0E09, 0x0E0A, 0x0E0B, 0x0E0C, 0x0E0D, 0x0E0E, 0x0E0F, // A-
        0x0E10, 0x0E11, 0x0E12, 0x0E13, 0x0E14, 0x0E15, 0x0E16, 0x0E17, 0x0E18, 0x0E19, 0x0E1A, 0x0E1B, 0x0E1C, 0x0E1D, 0x0E1E, 0x0E1F, // B-
        0x0E20, 0x0E21, 0x0E22, 0x0E23, 0x0E24, 0x0E25, 0x0E26, 0x0E27, 0x0E28, 0x0E29, 0x0E2A, 0x0E2B, 0x0E2C, 0x0E2D, 0x0E2E, 0x0E2F, // C-
        0x0E30, 0x0E31, 0x0E32, 0x0E33, 0x0E34, 0x0E35, 0x0E36, 0x0E37, 0x0E38, 0x0E39, 0x0E3A, 0x0000, 0x0000, 0x0000, 0x0000, 0x0E3F, // D-
        0x0E40, 0x0E41, 0x0E42, 0x0E43, 0x0E44, 0x0E45, 0x0E46, 0x0E47, 0x0E48, 0x0E49, 0x0E4A, 0x0E4B, 0x0E4C, 0x0E4D, 0x0E4E, 0x0E4F, // E-
        0x0E50, 0x0E51, 0x0E52, 0x0E53, 0x0E54, 0x0E55, 0x0E56, 0x0E57, 0x0E58, 0x0E59, 0x0E5A, 0x0E5B, 0x0000, 0x0000, 0x0000, 0x0000  // F-
    };

    // Compatible with ISO/IEC 8859-13
    private static final char[] TABLE_09_AKA_8859_13 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x201D, 0x00A2, 0x00A3, 0x00A4, 0x201E, 0x00A6, 0x00A7, 0x00D8, 0x00A9, 0x0156, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00C6, // A-
        0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x201C, 0x00B5, 0x00B6, 0x00B7, 0x00F8, 0x00B9, 0x0157, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00E6, // B-
        0x0104, 0x012E, 0x0100, 0x0106, 0x00C4, 0x00C5, 0x0118, 0x0112, 0x010C, 0x00C9, 0x0179, 0x0116, 0x0122, 0x0136, 0x012A, 0x013B, // C-
        0x0160, 0x0143, 0x0145, 0x00D3, 0x014C, 0x00D5, 0x00D6, 0x00D7, 0x0172, 0x0141, 0x015A, 0x016A, 0x00DC, 0x017B, 0x017D, 0x00DF, // D-
        0x0105, 0x012F, 0x0101, 0x0107, 0x00E4, 0x00E5, 0x0119, 0x0113, 0x010D, 0x00E9, 0x017A, 0x0117, 0x0123, 0x0137, 0x012B, 0x013C, // E-
        0x0161, 0x0144, 0x0146, 0x00F3, 0x014D, 0x00F5, 0x00F6, 0x00F7, 0x0173, 0x0142, 0x015B, 0x016B, 0x00FC, 0x017C, 0x017E, 0x2019  // F-
    };

    // Compatible with ISO/IEC 8859-14
    private static final char[] TABLE_0A_AKA_8859_14 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x1E02, 0x1E03, 0x00A3, 0x010A, 0x010B, 0x1E0A, 0x00A7, 0x1E80, 0x00A9, 0x1EB2, 0x1E0B, 0x1EF2, 0x00AD, 0x00AE, 0x0178, // A-
        0x1E1E, 0x1E1F, 0x0120, 0x0121, 0x1E40, 0x1E41, 0x00B6, 0x1E56, 0x1E81, 0x1E57, 0x1EB3, 0x1E60, 0x1EF3, 0x1E84, 0x1E85, 0x1E61, // B-
        0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, 0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, // C-
        0x0174, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x1E6A, 0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x0176, 0x00DF, // D-
        0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF, // E-
        0x0175, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x1E6B, 0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x0177, 0x00FF  // F-
    };

    // Compatible with ISO/IEC 8859-15
    private static final char[] TABLE_0B_AKA_8859_15 = {
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1-
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 2-
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 3-
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 4-
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 5-
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 6-
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 7-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8-
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9-
        0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x20AC, 0x00A5, 0x0160, 0x00A7, 0x0161, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF, // A-
        0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x017D, 0x00B5, 0x00B6, 0x00B7, 0x017E, 0x00B9, 0x00BA, 0x00BB, 0x0152, 0x0153, 0x0178, 0x00BF, // B-
        0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, 0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, // C-
        0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF, // D-
        0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF, // E-
        0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, 0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF  // F-
    };
}
